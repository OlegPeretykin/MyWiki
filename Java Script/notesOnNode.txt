

Object.assign({}, <var name>) - copy object as value, default method - "as reference"
!!! вложенные обьекты НЕ копируются, копируются указатели на них !!!
------------

{...<object name>} - "..." оператор разделения на свойстваю При присвоении КОПИРУЕТ свойства.
const person = {
	name: GGG,
	age: 56
}
const person2 = {...person}
-------------

Полное копирование возможно через JSON
сначала - stringify, потом - parse
-----------------------

!!! При вызове в функции НЕ обьявленной переменной НЕ возникает ошибка - переменная автоматически создаётся в глобальной области.

'use strict' - в самом начале кода запрещает автоматическое создание переменных
----------------

Следующие ключевые слова не разрешается использовать в качестве иден-
тификаторов:
break case catch class const continue debugger default delete do
else enum export extends false finally for function if import in instanceof
new null return super switch this throw true try typeof var void while with

В строгом режиме запрещены также такие ключевые слова:
implements interface let package protected private public static

Следующие ключевые слова добавлены в язык недавно; их можно исполь-
зовать в качестве идентификаторов ради обратной совместимости, но лучше 
этого не делать:
await as async from get of set target yield
-------------------

Заметим, что оператор / всегда возвращает результат с пла-
вающей точкой, даже если оба операнда целые.
---------------

Чтобы включить в строку знаки обратной кавычки, доллара или обрат-
ной косой черты, следует экранировать их знаком обратной косой черты: 
`\`\$\\` – строка, содержащая три символа: `$\.
----------------

В JavaScript массив – это просто объект, в котором именами свойств являются 
строки '0', '1', '2' и т. д. (Строки используются, потому что числа не могут 
быть именами свойств.)
Для удобства аргумент внутри скобок автоматически преобразуется в строку. 
Можно писать также numbers[1], что 
создает иллюзию, будто мы работаем с таким же массивом, как в Java или C++.
----------------------

Любое сравнение с NaN дает false
----------------------------

Как в Java и Python, равенство объектов (включая массивы) означает, что 
оба операнда ссылаются на один и тот же объект. Ссылки на разные объекты 
никогда не равны, даже если содержимое объектов одинаково.
---------------------

Нестрогое сравнение x == null на самом деле истинно, если x равно 
undefined или null,  а  x != null – если x не равно ни тому, ни другому. Некоторые 
программисты, твердо решившие не пользоваться нестрогим равенством, делают 
исключение для этого случая.
-----------------

Операторы && и || вычисляются лениво. Если левый операнд определяет 
результат (похож на false в случае &&, похож на true в случае ||), то правый 
операнд не вычисляется вовсе
-------------------

Выражение x?.propertyName возвращает значение свойства x с именем pro­
pertyName, если x не равно ни undefined, ни null, а в противном случае undefined.
--------------------------

Во многих случаях различие в производительности между switch и эквива-
лентным множеством предложений if пренебрежимо мало. Но если ветвей много, 
то виртуальная машина может построить «таблицу переходов» для эффективного 
перехода к нужной ветви case.
--------------------

Цикл while не исполняется ни разу, если условие в самом начале равно 
false. Если вы хотите, чтобы блок был выполнен хотя бы один раз, проверку 
нужно перенести в конец цикла, т. е. воспользоваться циклом do-while с та-
ким синтаксисом:
do предложение while (условие)
---------------------------

При обходе строки цикл for of посещает каждую кодовую точку Юникода. 
Именно такое поведение и желательно. Например:
let greeting = 'Hello Ȫ'
for (const c of greeting)
  console.log(c) // печатается H e l l o, пробел и Ȫ
Нам не нужно думать о том, что Ȫ занимает две кодовые единицы, храня-
щиеся в элементах greeting[6] и greeting[7].
---------------------

Цикл for of нельзя использовать для обхода значений свойств произвольного 
объекта, да это вряд ли и нужно – значения свойств обычно не имеют смысла 
без ключей. Вместо этого можно обойти ключи в цикле for in
-----------------

Как было отмечено в главе 2, после предложения return в той же 
строке должна быть по крайней мере одна лексема, чтобы не произошло автома-
тической вставки точки с запятой. Например, если функция возвращает объект, то 
поставьте в той же строке хотя бы открывающую фигурную скобку:
return {
  average: (x + y) / 2,
  max: Math.max(x, y),
  . . .
}
--------------------

Если стрелочная функция не делает ничего, а только возвраща-
ет объектный литерал, то необходимо заключить объект в круглые скобки:
const stats = (x, y) => ({
  average: (x + y) / 2,
  distance: Math.abs(x - y)
})
В противном случае фигурные скобки будут интерпретированы как блок.
--------------------

метод map преобразует массив, применяя 
к каждому элементу некоторую функцию. Приведем практически полезный 
пример. Пусть требуется построить HTML-список, содержащий элементы 
массива. Можно сначала окружить каждый элемент тегами li:
const enclose = (tag, contents) => `<${tag}>${contents}</${tag}>`
const listItems = items.map(i => enclose('li', i))
---------------

Стандартная проверка на трушность
!!<var>
---------------

&& и || - "и" и "или"

!!! они выдают как результат, определяющее значение true или false выражение, а не "true" или "false"
по сути их можно использовать как if 
--------------

myArray.unshift(<var>) - добавляет элемент в начало массива
shift - удаляет перый элемент массива
----------

Object.keys(<object>) - создает массив имен свойств или индексов массива если обьект это массив
-------------

Object.values(<object>) - создает массив значений обьекта или массива если обьект это массив
--------

For of - итеррирует итеррируемый обьект
For (const a of 'kjgkg') { <какой то код>} посимвольно переберет литерал 'kjgkg'
---------------

 В  строгом  режиме  чтение  необъявленной  переменной  приводит 
к исключению ReferenceError. Проверить, что переменная была объявлена (и ини-
циализирована), с помощью конструкции
possiblyUndefinedVariable !== undefined
нельзя. Вместо этого используйте такую проверку:
typeof possiblyUndefinedVariable !== 'undefined'
-------------------

Math.max(...<array>) - лексема "..." позволяет обрабатывать массив любой длинны как числа, перечисленные через запятую
------------------

После выполнения предложения throw функция немедленно завершается. 
Не возвращается никакого значения, даже undefined. Выполнение продолжа-
ется не с места вызова функции, а в ближайшей ветви catch или finally, как 
описано в следующих разделах.
-------------------

Предостережение. Ссылка this работает только в функциях, объявленных с по-
мощью слова function или краткого синтаксиса, в котором function опущено, но 
не в стрелочных функциях
------------------------

Методы класса с пометкой

static

НЕ наследуются экземплярами класса, но их можно использовать вызывая сам класс
он не добавляется в Prototype порождаемых обьектов
это метод обьекта класса
----------------------------

Конструкция вида

class <NewClass> extends <Class> { 
	<function> {
	}
}

создает новый класс на основе старого, добавляя новые методы (и наверное свойства), которые наследуются экземплярами нового класса
----------------

Асинхронная функция всегда возвращает Промис
async function <name function>() {}
или
const <name function> = async() => {}

<name function>()
	.then(value => {})
	.catch(error => {})
	
По сути это упрощенная синтаксическая конструкция для работы с Промисами

await можно использовать только в асинхронных функциях помеченых словом "async"
но веб-браузеры позволяют вставлять await где угодно, например:
a = await getDataFromMyHost()
однако при отклонении промиса вывалится не пойманая ошибка и выполнение кода прекратится - ловить надо самому
-----------------

performace.now() - текущее время
---------------------

Правильно комментировать функции надо так:

/**
 * Return difference
 * @param {number} a 
 * @param {number} b 
 * @returns {number} difference between a and b
 */
function diff(a, b) {
    return(Math.abs(a-b))
}

Тогда интерпретатор будет предполагать значения и значительно ускорится.
Так же эта информация выводится при работе с функцией в тексте кода и упрощает работу.
----------------------------

setInterval() возвращает уникальный ID 
то есть:

let iDThisInterval = setInterval (() => {}, <interval in mSecond>) сохранит в переменной значение ID процесса, которое может быть использовано для его остановки функцией clearInterval()

clearInterval(iDThisInterval) - отключит ранее запущенный фоновый процесс с ID в этой переменной.
---------------


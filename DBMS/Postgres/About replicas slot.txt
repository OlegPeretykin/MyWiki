Ваше замечание из предыдущего анализа касается следующей части скрипта 00_init.sql:
sql

SELECT pg_create_physical_replication_slot('replication_slot1');
SELECT pg_create_physical_replication_slot('replication_slot2');
SELECT pg_create_physical_replication_slot('replication_slot3');
SELECT pg_create_physical_replication_slot('replication_slot4');

Давайте разберём, что означает это предупреждение и почему оно важно в контексте PostgreSQL с физической репликацией.
Что такое слоты репликации
Слот репликации (replication slot) в PostgreSQL — это механизм, который резервирует WAL (Write-Ahead Log) для определённой реплики. Он гарантирует, что WAL-логи, необходимые для репликации, не будут удалены до того, как реплика их обработает.

Физическая репликация: Использует слоты для передачи изменений с primary-сервера на standby-серверы (реплики).

Когда вы создаёте слот с помощью pg_create_physical_replication_slot, PostgreSQL начинает сохранять WAL с момента создания слота, ожидая, что реплика подключится и будет его "потреблять".
Что значит "без проверки использования"
В вашем скрипте слоты (replication_slot1, replication_slot2, и т.д.) создаются без проверки, подключена ли к ним реплика.

PostgreSQL не проверяет автоматически, используется ли слот (то есть, есть ли активное соединение от реплики). Если реплика не подключается или отключается, слот остаётся "активным" на primary-сервере.

Почему слоты накапливают WAL
WAL (журнал предзаписи) — это файлы, в которых PostgreSQL записывает все изменения в базе данных перед их применением. Они хранятся в каталоге pg_wal (обычно внутри /var/lib/postgresql/data/pg_wal).

Когда слот репликации активен, PostgreSQL сохраняет WAL-файлы, начиная с точки, где слот был создан, до тех пор, пока реплика не подтвердит их получение (через wal_receiver).

Если реплика не подключена или перестала работать:
Слот не "освобождает" старые WAL-файлы.

PostgreSQL продолжает накапливать новые WAL-файлы, чтобы сохранить возможность восстановления реплики в будущем.

Почему это может заполнить диск
Размер WAL: Зависит от активности базы (например, вставки, обновления, удаления). Для базы 400-850 ГБ с высокой нагрузкой (150-250 подключений) WAL может расти быстро — десятки или сотни ГБ в час при интенсивных операциях.

Ограничение: Параметр max_wal_size (у вас 4 ГБ) ограничивает общий размер WAL, но не учитывает слоты. Если слоты активны, PostgreSQL будет сохранять WAL сверх max_wal_size, пока диск не заполнится.

Результат: Если реплики не подключены к слотам, pg_wal может занять всё доступное место на диске (/dev/sdb1, 1.7 ТБ у вас), что приведёт к остановке primary-сервера с ошибкой вроде no space left on device.

Пример сценария
Вы создаёте слот replication_slot1.

Реплика не подключается (или отключается из-за сбоя сети).

База продолжает работать, генерируя WAL (например, 10 ГБ/час).

Через 100 часов без активной реплики pg_wal займёт 1 ТБ, а у вас всего 1.7 ТБ на диске — это риск заполнения.

Как проверить
Посмотрите состояние слотов:
sql

SELECT slot_name, active, wal_status, restart_lsn FROM pg_replication_slots;

active = false: Реплика не подключена.

wal_status = 'reserved': WAL накапливается.

Проверьте размер pg_wal:
bash

docker exec -it postgres_primary du -sh /var/lib/postgresql/data/pg_wal

Как избежать проблемы
1. Создавайте слоты только при необходимости
Не создавайте все 4 слота заранее в 00_init.sql. Создавайте их вручную, когда реплика готова:
sql

SELECT pg_create_physical_replication_slot('replication_slot1');  -- После настройки реплики 1
SELECT pg_create_physical_replication_slot('replication_slot2');  -- После настройки реплики 2

У вас 2 реплики, так что достаточно 2 слотов для начала.

2. Удаляйте неиспользуемые слоты
Если реплика отключена, удалите её слот:
sql

SELECT pg_drop_replication_slot('replication_slot1');

Это освобождает накопленный WAL.

3. Настройте мониторинг
Используйте запрос для проверки:
sql

SELECT slot_name, active, pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn)) AS retained_wal
FROM pg_replication_slots
WHERE NOT active;

Если retained_wal растёт (например, >10 ГБ), пора действовать.

Добавьте алерт (например, через PMM), если размер pg_wal превышает 50 ГБ.

4. Ограничьте время хранения WAL
Включите wal_keep_size (например, 32 ГБ):
yaml

command:
  -c wal_keep_size=32GB

Это ограничит объём WAL, сохраняемый для слотов, но реплики должны успевать синхронизироваться.

5. Автоматизация
Настройте скрипт для проверки и удаления "мёртвых" слотов:
bash

docker exec postgres_primary psql -U acq -d acq -c "SELECT pg_drop_replication_slot(slot_name) FROM pg_replication_slots WHERE NOT active AND pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn) > 10737418240;"  # >10GB

Итог
Замечание объясняет: Создание слотов без подключённых реплик приводит к накоплению WAL, что может заполнить диск.

Риски: Для базы 400-850 ГБ с высокой нагрузкой это реальная угроза (1.7 ТБ на /dev/sdb1 может закончиться за дни или недели).

Решение: Создавайте слоты по мере необходимости, мониторьте их состояние и удаляйте неиспользуемые.

Добавьте в 00_init.sql только 2 слота для ваших реплик и настройте мониторинг. Всё ли понятно? Хотите скорректировать скрипт с учётом этого?


